<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Crossy Road Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url("https://fonts.googleapis.com/css?family=Press+Start+2P");

        body {
            margin: 0;
            font-family: "Press Start 2P", cursive;
            font-size: 1.2em;
            color: white;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            overflow: hidden;
        }

        button {
            outline: none;
            cursor: pointer;
            border: none;
            box-shadow: 3px 5px 0px 0px rgba(0, 0, 0, 0.75);
            transition: all 0.1s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 3px 7px 0px 0px rgba(0, 0, 0, 0.75);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 1px 3px 0px 0px rgba(0, 0, 0, 0.75);
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .hud.visible {
            opacity: 1;
        }

        #counter {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #fff;
        }

        #highScore {
            background: rgba(255, 215, 0, 0.8);
            color: #000;
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #000;
        }

        #speedometer {
            background: rgba(255, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #fff;
        }

        #powerupStatus {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(128, 0, 128, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #fff;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #powerupStatus.visible {
            opacity: 1;
        }

        #startScreen {
            position: absolute;
            min-width: 100%;
            min-height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
            z-index: 200;
        }

        #gameTitle {
            color: #4CAF50;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 3px 3px 0px #000;
        }

        #gameSubtitle {
            color: #fff;
            font-size: 1em;
            margin-bottom: 40px;
            text-align: center;
        }

        #end {
            position: absolute;
            min-width: 100%;
            min-height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            visibility: hidden;
            background: rgba(0, 0, 0, 0.8);
            z-index: 200;
        }

        #gameOverText {
            color: #ff4444;
            font-size: 2em;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0px #000;
        }

        #finalScore {
            color: #fff;
            font-size: 1.5em;
            margin-bottom: 20px;
        }

        .game-button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 20px 50px;
            font-family: inherit;
            font-size: 1em;
            border-radius: 10px;
            margin: 10px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #controls.visible {
            opacity: 1;
        }

        #controls div {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px;
            grid-gap: 10px;
        }

        #controls button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            font-size: 1.5em;
            border-radius: 10px;
            border: 2px solid #333;
        }

        #controls button:first-of-type {
            grid-column: 2;
            grid-row: 1;
        }

        #controls button:nth-of-type(2) {
            grid-column: 1;
            grid-row: 2;
        }

        #controls button:nth-of-type(3) {
            grid-column: 2;
            grid-row: 2;
        }

        #controls button:nth-of-type(4) {
            grid-column: 3;
            grid-row: 2;
        }

        .instructions {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.8em;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .instructions.visible {
            opacity: 1;
        }

        @media (max-width: 768px) {
            body { font-size: 1em; }
            .hud { flex-direction: column; align-items: flex-start; }
            #highScore { margin-top: 10px; }
            #gameTitle { font-size: 2em; }
        }
    </style>
</head>
<body>
    <div class="hud" id="hud">
        <div id="counter">Score: 0</div>
        <div id="speedometer">Speed: 1x</div>
        <div id="highScore">Best: 0</div>
    </div>

    <div id="powerupStatus">No Active Powerup</div>

    <div id="startScreen">
        <div id="gameTitle">CROSSY ROAD</div>
        <div id="gameSubtitle">Cross the road safely!<br>Avoid cars & trucks, collect coins & powerups!</div>
        <button id="startButton" class="game-button">START GAME</button>
    </div>

    <div id="end">
        <div id="gameOverText">GAME OVER!</div>
        <div id="finalScore">Final Score: 0</div>
        <button id="restartButton" class="game-button">RESTART</button>
    </div>

    <div id="controls">
        <div>
            <button id="forward">▲</button>
            <button id="left">◄</button>
            <button id="backward">▼</button>
            <button id="right">►</button>
        </div>
    </div>

    <div class="instructions">
        <div>Use Arrow Keys or Buttons to Move</div>
        <div>Avoid Cars & Trucks • Collect Coins & Powerups • Beat Your High Score!</div>
    </div>

    <script>
        // Game state management
        const gameState = {
            score: 0,
            highScore: localStorage.getItem('crossyRoadHighScore') || 0,
            speed: 1,
            coinsCollected: 0,
            isPlaying: false,
            gameStarted: false,
            // Powerup states
            activePowerup: null,
            powerupEndTime: 0,
            invulnerable: false,
            slowMotion: false,
            magnetActive: false,
            jumpBoostActive: false,
            scoreMultiplier: 1
        };

        // DOM elements
        const counterDOM = document.getElementById("counter");
        const endDOM = document.getElementById("end");
        const startScreenDOM = document.getElementById("startScreen");
        const speedometerDOM = document.getElementById("speedometer");
        const highScoreDOM = document.getElementById("highScore");
        const finalScoreDOM = document.getElementById("finalScore");
        const hudDOM = document.getElementById("hud");
        const controlsDOM = document.getElementById("controls");
        const instructionsDOM = document.querySelector(".instructions");
        const powerupStatusDOM = document.getElementById("powerupStatus");

        // Enhanced scene setup with better performance
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 500, 2000);
        
        const distance = 500;
        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -2, window.innerWidth / 2,
            window.innerHeight / 2, window.innerHeight / -2,
            0.1, 3000
        );

        // Optimized camera positioning
        camera.rotation.x = (45 * Math.PI) / 180;
        camera.rotation.y = (15 * Math.PI) / 180;
        camera.rotation.z = (5 * Math.PI) / 180;

        const initialCameraPositionY = -Math.tan(camera.rotation.x) * distance;
        const initialCameraPositionX = Math.tan(camera.rotation.y) * Math.sqrt(distance ** 2 + initialCameraPositionY ** 2);

        camera.position.set(initialCameraPositionX, initialCameraPositionY, distance);

        // Game constants (optimized)
        const zoom = 2;
        const chickenSize = 15;
        const positionWidth = 42;
        const columns = 17;
        const boardWidth = positionWidth * columns;
        const stepTime = 150; // Faster movement

        // Game variables
        let lanes = [];
        let currentLane = 0;
        let currentColumn = Math.floor(columns / 2);
        let previousTimestamp = null;
        let startMoving = false;
        let moves = [];
        let stepStartTimestamp = null;
        let coins = [];
        let powerups = [];

        // Performance optimization: Object pooling
        const objectPools = {
            cars: [],
            trucks: [],
            trees: [],
            coins: [],
            powerups: []
        };

        // Powerup types configuration
        const powerupTypes = {
            SHIELD: {
                color: 0x00ff00,
                duration: 8000,
                name: "Shield",
                description: "Invulnerable to collisions"
            },
            SLOW_MOTION: {
                color: 0x0088ff,
                duration: 6000,
                name: "Slow Motion",
                description: "Slows down all vehicles"
            },
            COIN_MAGNET: {
                color: 0xffd700,
                duration: 10000,
                name: "Coin Magnet",
                description: "Attracts nearby coins"
            },
            JUMP_BOOST: {
                color: 0xff8800,
                duration: 5000,
                name: "Jump Boost",
                description: "Higher and faster jumps"
            },
            SCORE_MULTIPLIER: {
                color: 0xff00ff,
                duration: 12000,
                name: "Score x2",
                description: "Double points for everything"
            }
        };

        // Enhanced textures with better performance
        const textureCache = new Map();
        
        function createOptimizedTexture(width, height, rects, color = "#ffffff") {
            const key = `${width}-${height}-${JSON.stringify(rects)}-${color}`;
            if (textureCache.has(key)) {
                return textureCache.get(key);
            }
            
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext("2d");
            context.fillStyle = color;
            context.fillRect(0, 0, width, height);
            context.fillStyle = "rgba(0,0,0,0.6)";
            rects.forEach((rect) => {
                context.fillRect(rect.x, rect.y, rect.w, rect.h);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            textureCache.set(key, texture);
            return texture;
        }

        // Optimized textures
        const carFrontTexture = createOptimizedTexture(40, 80, [{ x: 0, y: 10, w: 30, h: 60 }]);
        const carBackTexture = createOptimizedTexture(40, 80, [{ x: 10, y: 10, w: 30, h: 60 }]);
        const carRightSideTexture = createOptimizedTexture(110, 40, [
            { x: 10, y: 0, w: 50, h: 30 }, { x: 70, y: 0, w: 30, h: 30 }
        ]);
        const carLeftSideTexture = createOptimizedTexture(110, 40, [
            { x: 10, y: 10, w: 50, h: 30 }, { x: 70, y: 10, w: 30, h: 30 }
        ]);

        // Enhanced lighting system
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x454545, 0.6);
        scene.add(hemisphereLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(-100, -100, 200);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.setScalar(2048);
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 1000;
        directionalLight.shadow.camera.left = directionalLight.shadow.camera.bottom = -500;
        directionalLight.shadow.camera.right = directionalLight.shadow.camera.top = 500;
        scene.add(directionalLight);

        // Enhanced game configuration - Better lane distribution
        const laneTypes = ["car", "truck", "forest"];
        const baseLaneSpeeds = [2, 2.5, 3];
        const vehicleColors = [0xa52523, 0xbdb638, 0x78b14b, 0x4a90e2, 0x9b59b6];
        const treeHeights = [20, 35, 50, 65];

        // Function to determine safe lane probability based on progress
        function getSafeLaneProbability(laneIndex) {
            if (laneIndex < 5) return 0.6; // 60% safe lanes early game
            if (laneIndex < 15) return 0.45; // 45% safe lanes mid game
            if (laneIndex < 30) return 0.3; // 30% safe lanes late game
            return 0.2; // 20% safe lanes very late game
        }

        // Powerup system functions
        function createPowerup(type) {
            const powerup = new THREE.Group();
            const config = powerupTypes[type];
            
            // Main powerup body (cube)
            const body = new THREE.Mesh(
                new THREE.BoxBufferGeometry(12 * zoom, 12 * zoom, 12 * zoom),
                new THREE.MeshPhongMaterial({ 
                    color: config.color,
                    emissive: config.color,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.9
                })
            );
            body.position.z = 18 * zoom;
            body.castShadow = true;
            powerup.add(body);

            // Glowing effect
            const glow = new THREE.Mesh(
                new THREE.BoxBufferGeometry(16 * zoom, 16 * zoom, 16 * zoom),
                new THREE.MeshBasicMaterial({ 
                    color: config.color,
                    transparent: true,
                    opacity: 0.3
                })
            );
            glow.position.z = 18 * zoom;
            powerup.add(glow);

            powerup.userData = { 
                type: type,
                rotationSpeed: 0.05,
                bobSpeed: 0.003,
                baseY: 18 * zoom
            };
            
            return powerup;
        }

        function activatePowerup(type, timestamp) {
            const config = powerupTypes[type];
            gameState.activePowerup = type;
            gameState.powerupEndTime = timestamp + config.duration;

            // Apply powerup effects
            switch(type) {
                case 'SHIELD':
                    gameState.invulnerable = true;
                    chicken.material = chicken.children[0].material.clone();
                    chicken.children[0].material.emissive = new THREE.Color(0x00ff00);
                    chicken.children[0].material.emissiveIntensity = 0.3;
                    break;
                case 'SLOW_MOTION':
                    gameState.slowMotion = true;
                    break;
                case 'COIN_MAGNET':
                    gameState.magnetActive = true;
                    break;
                case 'JUMP_BOOST':
                    gameState.jumpBoostActive = true;
                    break;
                case 'SCORE_MULTIPLIER':
                    gameState.scoreMultiplier = 2;
                    break;
            }

            updatePowerupStatus();
        }

        function deactivatePowerup() {
            const type = gameState.activePowerup;
            
            // Remove powerup effects
            switch(type) {
                case 'SHIELD':
                    gameState.invulnerable = false;
                    chicken.children[0].material.emissive = new THREE.Color(0x000000);
                    chicken.children[0].material.emissiveIntensity = 0;
                    break;
                case 'SLOW_MOTION':
                    gameState.slowMotion = false;
                    break;
                case 'COIN_MAGNET':
                    gameState.magnetActive = false;
                    break;
                case 'JUMP_BOOST':
                    gameState.jumpBoostActive = false;
                    break;
                case 'SCORE_MULTIPLIER':
                    gameState.scoreMultiplier = 1;
                    break;
            }

            gameState.activePowerup = null;
            gameState.powerupEndTime = 0;
            updatePowerupStatus();
        }

        function updatePowerupStatus() {
            if (gameState.activePowerup) {
                const config = powerupTypes[gameState.activePowerup];
                const timeLeft = Math.max(0, (gameState.powerupEndTime - Date.now()) / 1000);
                powerupStatusDOM.textContent = `${config.name}: ${timeLeft.toFixed(1)}s`;
                powerupStatusDOM.classList.add('visible');
            } else {
                powerupStatusDOM.textContent = "No Active Powerup";
                powerupStatusDOM.classList.remove('visible');
            }
        }

        // Enhanced Chicken with better design
        function createChicken() {
            const chicken = new THREE.Group();

            // Body
            const body = new THREE.Mesh(
                new THREE.BoxBufferGeometry(chickenSize * zoom, chickenSize * zoom, 20 * zoom),
                new THREE.MeshPhongMaterial({ 
                    color: 0xffffff, 
                    flatShading: true,
                    shininess: 30
                })
            );
            body.position.z = 10 * zoom;
            body.castShadow = true;
            body.receiveShadow = true;
            chicken.add(body);

            // Crest
            const crest = new THREE.Mesh(
                new THREE.BoxBufferGeometry(3 * zoom, 6 * zoom, 4 * zoom),
                new THREE.MeshLambertMaterial({ color: 0xff0000, flatShading: true })
            );
            crest.position.set(0, -2 * zoom, 22 * zoom);
            crest.castShadow = true;
            chicken.add(crest);

            // Beak
            const beak = new THREE.Mesh(
                new THREE.BoxBufferGeometry(2 * zoom, 4 * zoom, 2 * zoom),
                new THREE.MeshLambertMaterial({ color: 0xffa500, flatShading: true })
            );
            beak.position.set(0, (chickenSize/2 + 1) * zoom, 18 * zoom);
            chicken.add(beak);

            return chicken;
        }

        // Enhanced Car with better performance
        function createCar() {
            if (objectPools.cars.length > 0) {
                return objectPools.cars.pop();
            }

            const car = new THREE.Group();
            const color = vehicleColors[Math.floor(Math.random() * vehicleColors.length)];

            // Main body
            const main = new THREE.Mesh(
                new THREE.BoxBufferGeometry(60 * zoom, 30 * zoom, 15 * zoom),
                new THREE.MeshPhongMaterial({ color, flatShading: true })
            );
            main.position.z = 12 * zoom;
            main.castShadow = true;
            main.receiveShadow = true;
            car.add(main);

            // Cabin with enhanced materials
            const cabin = new THREE.Mesh(
                new THREE.BoxBufferGeometry(33 * zoom, 24 * zoom, 12 * zoom),
                [
                    new THREE.MeshPhongMaterial({ color: 0xcccccc, flatShading: true, map: carBackTexture }),
                    new THREE.MeshPhongMaterial({ color: 0xcccccc, flatShading: true, map: carFrontTexture }),
                    new THREE.MeshPhongMaterial({ color: 0xcccccc, flatShading: true, map: carRightSideTexture }),
                    new THREE.MeshPhongMaterial({ color: 0xcccccc, flatShading: true, map: carLeftSideTexture }),
                    new THREE.MeshPhongMaterial({ color: 0xcccccc, flatShading: true }),
                    new THREE.MeshPhongMaterial({ color: 0xcccccc, flatShading: true })
                ]
            );
            cabin.position.set(6 * zoom, 0, 25.5 * zoom);
            cabin.castShadow = true;
            cabin.receiveShadow = true;
            car.add(cabin);

            // Wheels
            [[-18, 0], [18, 0]].forEach(([x, y]) => {
                const wheel = new THREE.Mesh(
                    new THREE.BoxBufferGeometry(12 * zoom, 33 * zoom, 12 * zoom),
                    new THREE.MeshLambertMaterial({ color: 0x333333, flatShading: true })
                );
                wheel.position.set(x * zoom, y, 6 * zoom);
                car.add(wheel);
            });

            return car;
        }

        // Enhanced Coin system - Fixed to rotate only around its own axis (Z-axis)
        function createCoin() {
            const coin = new THREE.Group();
            
            const coinMesh = new THREE.Mesh(
                new THREE.CylinderGeometry(8 * zoom, 8 * zoom, 3 * zoom, 8),
                new THREE.MeshPhongMaterial({ 
                    color: 0xffd700, 
                    shininess: 100,
                    emissive: 0x111100
                })
            );
            coinMesh.position.z = 15 * zoom;
            coinMesh.castShadow = true;
            coin.add(coinMesh);

            // Rotation animation - only around its own axis (Z-axis like Earth)
            coin.userData = { rotationSpeed: 0.03 };
            
            return coin;
        }

        // Enhanced Lane generation with proper coin placement and better distribution - Increased coin frequency
        function createLane(index) {
            const lane = {
                index: index,
                type: "field", // Default to field
                mesh: new THREE.Group()
            };

            // Determine lane type based on index and probability
            if (index <= 0) {
                lane.type = "field";
            } else {
                const safeLaneProbability = getSafeLaneProbability(index);
                if (Math.random() < safeLaneProbability) {
                    // Choose between field and forest for safe lanes
                    lane.type = Math.random() < 0.7 ? "field" : "forest";
                } else {
                    // Choose between car and truck for dangerous lanes
                    lane.type = Math.random() < 0.7 ? "car" : "truck";
                }
            }

            switch (lane.type) {
                case "field":
                    lane.mesh = createGrass();
                    // Increased coin probability: 60% chance for coins in safe fields
                    if (index > 0 && Math.random() < 0.6) {
                        const coin = createCoin();
                        const coinPosition = Math.floor(Math.random() * columns);
                        coin.position.x = (coinPosition * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2;
                        lane.mesh.add(coin);
                        coins.push({ coin, lane: index, column: coinPosition });
                    }
                    
                    // Add powerups (15% chance in safe fields)
                    if (index > 0 && Math.random() < 0.15) {
                        const powerupTypeKeys = Object.keys(powerupTypes);
                        const randomType = powerupTypeKeys[Math.floor(Math.random() * powerupTypeKeys.length)];
                        const powerup = createPowerup(randomType);
                        let powerupPosition;
                        let attempts = 0;
                        do {
                            powerupPosition = Math.floor(Math.random() * columns);
                            attempts++;
                        } while (attempts < 10 && coins.some(c => c.lane === index && c.column === powerupPosition));
                        
                        powerup.position.x = (powerupPosition * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2;
                        lane.mesh.add(powerup);
                        powerups.push({ powerup, lane: index, column: powerupPosition });
                    }
                    break;

                case "forest":
                    lane.mesh = createGrass();
                    lane.occupiedPositions = new Set();
                    lane.trees = createTrees(lane);
                    // Increased coin probability: 40% chance for coins in forests
                    if (index > 0 && Math.random() < 0.4) {
                        const coin = createCoin();
                        let coinPosition;
                        let attempts = 0;
                        do {
                            coinPosition = Math.floor(Math.random() * columns);
                            attempts++;
                        } while (lane.occupiedPositions.has(coinPosition) && attempts < 10);
                        
                        if (!lane.occupiedPositions.has(coinPosition)) {
                            coin.position.x = (coinPosition * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2;
                            lane.mesh.add(coin);
                            coins.push({ coin, lane: index, column: coinPosition });
                        }
                    }
                    
                    // Add powerups to forests (10% chance)
                    if (index > 0 && Math.random() < 0.1) {
                        const powerupTypeKeys = Object.keys(powerupTypes);
                        const randomType = powerupTypeKeys[Math.floor(Math.random() * powerupTypeKeys.length)];
                        const powerup = createPowerup(randomType);
                        let powerupPosition;
                        let attempts = 0;
                        do {
                            powerupPosition = Math.floor(Math.random() * columns);
                            attempts++;
                        } while ((lane.occupiedPositions.has(powerupPosition) || 
                                coins.some(c => c.lane === index && c.column === powerupPosition)) && attempts < 10);
                        
                        if (!lane.occupiedPositions.has(powerupPosition)) {
                            powerup.position.x = (powerupPosition * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2;
                            lane.mesh.add(powerup);
                            powerups.push({ powerup, lane: index, column: powerupPosition });
                        }
                    }
                    break;

                case "car":
                case "truck":
                    lane.mesh = createRoad();
                    lane.direction = Math.random() >= 0.5;
                    lane.vehicles = lane.type === "car" ? createCars(lane) : createTrucks(lane);
                    lane.speed = (baseLaneSpeeds[Math.floor(Math.random() * baseLaneSpeeds.length)] * gameState.speed);
                    
                    // Increased coin probability: 25% chance for coins on roads (was 15%)
                    if (index > 0 && Math.random() < 0.25) {
                        const coin = createCoin();
                        // Find a safe position between vehicles
                        const occupiedPositions = new Set();
                        lane.vehicles.forEach(vehicle => {
                            const vehicleColumn = Math.floor((vehicle.position.x + (boardWidth * zoom) / 2) / (positionWidth * zoom));
                            occupiedPositions.add(vehicleColumn);
                            occupiedPositions.add(vehicleColumn - 1);
                            occupiedPositions.add(vehicleColumn + 1);
                        });
                        
                        let coinPosition;
                        let attempts = 0;
                        do {
                            coinPosition = Math.floor(Math.random() * columns);
                            attempts++;
                        } while (occupiedPositions.has(coinPosition) && attempts < 20);
                        
                        if (!occupiedPositions.has(coinPosition)) {
                            coin.position.x = (coinPosition * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2;
                            lane.mesh.add(coin);
                            coins.push({ coin, lane: index, column: coinPosition });
                        }
                    }
                    break;
            }

            return lane;
        }

        // Enhanced grass creation
        function createGrass() {
            const grass = new THREE.Group();
            
            const geometry = new THREE.BoxBufferGeometry(boardWidth * zoom, positionWidth * zoom, 3 * zoom);
            const materials = [
                new THREE.MeshLambertMaterial({ color: 0xbaf455 }),
                new THREE.MeshLambertMaterial({ color: 0x99c846 }),
                new THREE.MeshLambertMaterial({ color: 0x99c846 })
            ];

            materials.forEach((material, index) => {
                const section = new THREE.Mesh(geometry, material);
                section.position.x = (index - 1) * boardWidth * zoom;
                section.position.z = 1.5 * zoom;
                section.receiveShadow = true;
                grass.add(section);
            });

            return grass;
        }

        // Enhanced road creation
        function createRoad() {
            const road = new THREE.Group();
            
            const geometry = new THREE.PlaneBufferGeometry(boardWidth * zoom, positionWidth * zoom);
            const materials = [
                new THREE.MeshPhongMaterial({ color: 0x454a59 }),
                new THREE.MeshPhongMaterial({ color: 0x393d49 })
            ];

            [0, -1, 1].forEach((offset, index) => {
                const section = new THREE.Mesh(geometry, materials[index > 0 ? 1 : 0]);
                section.position.x = offset * boardWidth * zoom;
                section.receiveShadow = true;
                road.add(section);
            });

            return road;
        }

        // Enhanced trees creation
        function createTrees(lane) {
            const treeCount = Math.floor(Math.random() * 3) + 2; // 2-4 trees per forest lane
            return Array.from({length: treeCount}, () => {
                const tree = new THREE.Group();
                let position;
                do {
                    position = Math.floor(Math.random() * columns);
                } while (lane.occupiedPositions.has(position));
                lane.occupiedPositions.add(position);

                // Trunk
                const trunk = new THREE.Mesh(
                    new THREE.BoxBufferGeometry(15 * zoom, 15 * zoom, 20 * zoom),
                    new THREE.MeshPhongMaterial({ color: 0x4d2926, flatShading: true })
                );
                trunk.position.z = 10 * zoom;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                tree.add(trunk);

                // Crown with varied heights
                const height = treeHeights[Math.floor(Math.random() * treeHeights.length)];
                const crown = new THREE.Mesh(
                    new THREE.BoxBufferGeometry(30 * zoom, 30 * zoom, height * zoom),
                    new THREE.MeshLambertMaterial({ color: 0x7aa21d, flatShading: true })
                );
                crown.position.z = (height / 2 + 20) * zoom;
                crown.castShadow = true;
                tree.add(crown);

                tree.position.x = (position * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2;
                lane.mesh.add(tree);
                return tree;
            });
        }

        // Enhanced vehicle creation functions
        function createCars(lane) {
            const occupiedPositions = new Set();
            const carCount = Math.floor(Math.random() * 2) + 2; // 2-3 cars per lane
            return Array.from({length: carCount}, () => {
                const car = createCar();
                let position;
                do {
                    position = Math.floor((Math.random() * columns) / 2);
                } while (occupiedPositions.has(position));
                occupiedPositions.add(position);
                
                car.position.x = (position * positionWidth * 2 + positionWidth / 2) * zoom - (boardWidth * zoom) / 2;
                if (!lane.direction) car.rotation.z = Math.PI;
                lane.mesh.add(car);
                return car;
            });
        }

        function createTrucks(lane) {
            const occupiedPositions = new Set();
            const truckCount = Math.floor(Math.random() * 2) + 1; // 1-2 trucks per lane
            return Array.from({length: truckCount}, () => {
                const truck = createTruck();
                let position;
                do {
                    position = Math.floor((Math.random() * columns) / 3);
                } while (occupiedPositions.has(position));
                occupiedPositions.add(position);
                
                truck.position.x = (position * positionWidth * 3 + positionWidth / 2) * zoom - (boardWidth * zoom) / 2;
                if (!lane.direction) truck.rotation.z = Math.PI;
                lane.mesh.add(truck);
                return truck;
            });
        }

        // Enhanced truck creation
        function createTruck() {
            if (objectPools.trucks.length > 0) {
                return objectPools.trucks.pop();
            }

            const truck = new THREE.Group();
            const color = vehicleColors[Math.floor(Math.random() * vehicleColors.length)];

            // Base
            const base = new THREE.Mesh(
                new THREE.BoxBufferGeometry(100 * zoom, 25 * zoom, 5 * zoom),
                new THREE.MeshLambertMaterial({ color: 0xb4c6fc, flatShading: true })
            );
            base.position.z = 10 * zoom;
            truck.add(base);

            // Cargo
            const cargo = new THREE.Mesh(
                new THREE.BoxBufferGeometry(75 * zoom, 35 * zoom, 40 * zoom),
                new THREE.MeshPhongMaterial({ color: 0xb4c6fc, flatShading: true })
            );
            cargo.position.set(15 * zoom, 0, 30 * zoom);
            cargo.castShadow = true;
            cargo.receiveShadow = true;
            truck.add(cargo);

            // Cabin
            const cabin = new THREE.Mesh(
                new THREE.BoxBufferGeometry(25 * zoom, 30 * zoom, 30 * zoom),
                new THREE.MeshPhongMaterial({ color, flatShading: true })
            );
            cabin.position.set(-40 * zoom, 0, 20 * zoom);
            cabin.castShadow = true;
            cabin.receiveShadow = true;
            truck.add(cabin);

            // Wheels
            [[-38, 0], [-10, 0], [30, 0]].forEach(([x, y]) => {
                const wheel = new THREE.Mesh(
                    new THREE.BoxBufferGeometry(12 * zoom, 33 * zoom, 12 * zoom),
                    new THREE.MeshLambertMaterial({ color: 0x333333, flatShading: true })
                );
                wheel.position.set(x * zoom, y, 6 * zoom);
                truck.add(wheel);
            });

            return truck;
        }

        // Game initialization
        function initializeGame() {
            // Clear existing lanes
            lanes.forEach(lane => scene.remove(lane.mesh));
            
            // Reset game state
            gameState.score = 0;
            gameState.speed = 1;
            gameState.coinsCollected = 0;
            gameState.isPlaying = true;
            gameState.gameStarted = true;
            
            // Reset powerup states
            gameState.activePowerup = null;
            gameState.powerupEndTime = 0;
            gameState.invulnerable = false;
            gameState.slowMotion = false;
            gameState.magnetActive = false;
            gameState.jumpBoostActive = false;
            gameState.scoreMultiplier = 1;
            
            // Reset position variables
            currentLane = 0;
            currentColumn = Math.floor(columns / 2);
            previousTimestamp = null;
            startMoving = false;
            moves = [];
            stepStartTimestamp = null;
            coins = [];
            powerups = [];

            // Generate initial lanes with better distribution
            lanes = [];
            for (let i = -9; i <= 9; i++) {
                const lane = createLane(i);
                lane.mesh.position.y = i * positionWidth * zoom;
                scene.add(lane.mesh);
                if (i >= 0) lanes.push(lane);
            }

            // Reset chicken position and appearance
            chicken.position.set(0, 0, 0);
            chicken.children[0].material.emissive = new THREE.Color(0x000000);
            chicken.children[0].material.emissiveIntensity = 0;
            
            camera.position.set(initialCameraPositionX, initialCameraPositionY, distance);
            directionalLight.position.set(-100, -100, 200);

            // Show game UI
            hudDOM.classList.add('visible');
            controlsDOM.classList.add('visible');
            instructionsDOM.classList.add('visible');

            updateHUD();
            updatePowerupStatus();
        }

        // Create chicken
        const chicken = createChicken();
        scene.add(chicken);

        // Enhanced renderer setup
        const renderer = new THREE.WebGLRenderer({ 
            alpha: true, 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Enhanced HUD updates
        function updateHUD() {
            counterDOM.textContent = `Score: ${gameState.score}`;
            speedometerDOM.textContent = `Speed: ${gameState.speed.toFixed(1)}x`;
            highScoreDOM.textContent = `Best: ${gameState.highScore}`;
        }

        // Enhanced movement function with jump boost
        function move(direction) {
            if (!gameState.isPlaying) return;

            const finalPositions = moves.reduce((position, move) => {
                if (move === "forward") return { lane: position.lane + 1, column: position.column };
                if (move === "backward") return { lane: position.lane - 1, column: position.column };
                if (move === "left") return { lane: position.lane, column: position.column - 1 };
                if (move === "right") return { lane: position.lane, column: position.column + 1 };
            }, { lane: currentLane, column: currentColumn });

            // Boundary and collision checks
            if (direction === "forward") {
                if (lanes[finalPositions.lane + 1] && 
                    lanes[finalPositions.lane + 1].type === "forest" &&
                    lanes[finalPositions.lane + 1].occupiedPositions.has(finalPositions.column)) return;
                if (!stepStartTimestamp) startMoving = true;
                addLane();
            } else if (direction === "backward") {
                if (finalPositions.lane === 0) return;
                if (lanes[finalPositions.lane - 1] &&
                    lanes[finalPositions.lane - 1].type === "forest" &&
                    lanes[finalPositions.lane - 1].occupiedPositions.has(finalPositions.column)) return;
                if (!stepStartTimestamp) startMoving = true;
            } else if (direction === "left") {
                if (finalPositions.column === 0) return;
                if (lanes[finalPositions.lane].type === "forest" &&
                    lanes[finalPositions.lane].occupiedPositions.has(finalPositions.column - 1)) return;
                if (!stepStartTimestamp) startMoving = true;
            } else if (direction === "right") {
                if (finalPositions.column === columns - 1) return;
                if (lanes[finalPositions.lane].type === "forest" &&
                    lanes[finalPositions.lane].occupiedPositions.has(finalPositions.column + 1)) return;
                if (!stepStartTimestamp) startMoving = true;
            }

            moves.push(direction);
        }

        // Enhanced lane addition
        function addLane() {
            const index = lanes.length;
            const lane = createLane(index);
            lane.mesh.position.y = index * positionWidth * zoom;
            scene.add(lane.mesh);
            lanes.push(lane);
        }

        // Enhanced collision detection with shield protection
        function checkCollisions() {
            const currentLaneObj = lanes[currentLane];
            if (!currentLaneObj) return;

            // Vehicle collision (with shield protection)
            if (currentLaneObj.type === "car" || currentLaneObj.type === "truck") {
                if (!gameState.invulnerable) {
                    const chickenMinX = chicken.position.x - (chickenSize * zoom) / 2;
                    const chickenMaxX = chicken.position.x + (chickenSize * zoom) / 2;
                    const vehicleLength = currentLaneObj.type === "car" ? 60 : 105;

                    currentLaneObj.vehicles.forEach(vehicle => {
                        const vehicleMinX = vehicle.position.x - (vehicleLength * zoom) / 2;
                        const vehicleMaxX = vehicle.position.x + (vehicleLength * zoom) / 2;

                        if (chickenMaxX > vehicleMinX && chickenMinX < vehicleMaxX) {
                            gameOver();
                        }
                    });
                }
            }

            // Coin collection with magnet effect
            coins.forEach((coinData, index) => {
                if (coinData.lane === currentLane) {
                    const chickenMinX = chicken.position.x - (chickenSize * zoom) / 2;
                    const chickenMaxX = chicken.position.x + (chickenSize * zoom) / 2;
                    const coinX = coinData.coin.position.x;
                    
                    let collectDistance = 10 * zoom;
                    if (gameState.magnetActive) {
                        collectDistance = 30 * zoom; // Larger collection radius with magnet
                    }
                    
                    if (chickenMaxX > coinX - collectDistance && chickenMinX < coinX + collectDistance) {
                        collectCoin(index, coinData);
                    }
                }
            });

            // Powerup collection
            powerups.forEach((powerupData, index) => {
                if (powerupData.lane === currentLane) {
                    const chickenMinX = chicken.position.x - (chickenSize * zoom) / 2;
                    const chickenMaxX = chicken.position.x + (chickenSize * zoom) / 2;
                    const powerupX = powerupData.powerup.position.x;
                    
                    if (chickenMaxX > powerupX - 15 * zoom && chickenMinX < powerupX + 15 * zoom) {
                        collectPowerup(index, powerupData);
                    }
                }
            });
        }

        // Enhanced coin collection with score multiplier
        function collectCoin(index, coinData) {
            coinData.coin.parent.remove(coinData.coin);
            coins.splice(index, 1);
            gameState.coinsCollected++;
            const coinPoints = 10 * gameState.scoreMultiplier;
            gameState.score += coinPoints;
            updateHUD();
        }

        // Powerup collection function
        function collectPowerup(index, powerupData) {
            powerupData.powerup.parent.remove(powerupData.powerup);
            const powerupType = powerupData.powerup.userData.type;
            powerups.splice(index, 1);
            
            // Deactivate current powerup if any
            if (gameState.activePowerup) {
                deactivatePowerup();
            }
            
            // Activate new powerup
            activatePowerup(powerupType, Date.now());
            
            // Bonus points for collecting powerup
            const powerupPoints = 25 * gameState.scoreMultiplier;
            gameState.score += powerupPoints;
            updateHUD();
        }

        // Enhanced game over function
        function gameOver() {
            gameState.isPlaying = false;
            
            // Deactivate any active powerup
            if (gameState.activePowerup) {
                deactivatePowerup();
            }
            
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('crossyRoadHighScore', gameState.highScore);
            }
            
            finalScoreDOM.textContent = `Final Score: ${gameState.score}`;
            endDOM.style.visibility = "visible";
        }

        // Start game function
        function startGame() {
            startScreenDOM.style.display = "none";
            initializeGame();
        }

        // Restart game function
        function restartGame() {
            endDOM.style.visibility = "hidden";
            initializeGame();
        }

        // Enhanced animation loop with powerup animations
        function animate(timestamp) {
            requestAnimationFrame(animate);

            if (!previousTimestamp) previousTimestamp = timestamp;
            const delta = timestamp - previousTimestamp;
            previousTimestamp = timestamp;

            if (!gameState.isPlaying && gameState.gameStarted) {
                renderer.render(scene, camera);
                return;
            }

            if (!gameState.gameStarted) {
                renderer.render(scene, camera);
                return;
            }

            // Check for powerup expiration
            if (gameState.activePowerup && Date.now() > gameState.powerupEndTime) {
                deactivatePowerup();
            }

            // Update powerup status display
            if (gameState.activePowerup) {
                updatePowerupStatus();
            }

            // Animate vehicles with slow motion effect
            lanes.forEach(lane => {
                if (lane.type === "car" || lane.type === "truck") {
                    const boundaryLeft = (-boardWidth * zoom) / 2 - positionWidth * 2 * zoom;
                    const boundaryRight = (boardWidth * zoom) / 2 + positionWidth * 2 * zoom;
                    
                    const speedMultiplier = gameState.slowMotion ? 0.3 : 1;

                    lane.vehicles.forEach(vehicle => {
                        if (lane.direction) {
                            vehicle.position.x = vehicle.position.x < boundaryLeft 
                                ? boundaryRight 
                                : vehicle.position.x - (lane.speed / 16) * delta * speedMultiplier;
                        } else {
                            vehicle.position.x = vehicle.position.x > boundaryRight 
                                ? boundaryLeft 
                                : vehicle.position.x + (lane.speed / 16) * delta * speedMultiplier;
                        }
                    });
                }
            });

            // Animate coins - Fixed to only rotate around their own axis (Z-axis like Earth)
            coins.forEach(coinData => {
                coinData.coin.rotation.z += coinData.coin.userData.rotationSpeed;
            });

            // Animate powerups with rotation and bobbing
            powerups.forEach(powerupData => {
                const powerup = powerupData.powerup;
                powerup.rotation.x += powerup.userData.rotationSpeed;
                powerup.rotation.y += powerup.userData.rotationSpeed * 0.7;
                powerup.rotation.z += powerup.userData.rotationSpeed * 0.5;
                
                // Bobbing effect
                const bobOffset = Math.sin(timestamp * powerup.userData.bobSpeed) * 3 * zoom;
                powerup.position.z = powerup.userData.baseY + bobOffset;
                
                // Pulsing glow effect
                const glowIntensity = 0.3 + Math.sin(timestamp * 0.005) * 0.2;
                powerup.children[1].material.opacity = glowIntensity;
            });

            // Handle player movement with jump boost
            if (startMoving) {
                stepStartTimestamp = timestamp;
                startMoving = false;
            }

            if (stepStartTimestamp) {
                const currentStepTime = gameState.jumpBoostActive ? stepTime * 0.7 : stepTime;
                const moveDeltaTime = timestamp - stepStartTimestamp;
                const moveDeltaDistance = Math.min(moveDeltaTime / currentStepTime, 1) * positionWidth * zoom;
                const jumpHeight = gameState.jumpBoostActive ? 12 : 8;
                const jumpDeltaDistance = Math.sin(Math.min(moveDeltaTime / currentStepTime, 1) * Math.PI) * jumpHeight * zoom;

                switch (moves[0]) {
                    case "forward":
                        const positionY = currentLane * positionWidth * zoom + moveDeltaDistance;
                        camera.position.y = initialCameraPositionY + positionY;
                        directionalLight.position.y = -100 + positionY;
                        chicken.position.y = positionY;
                        chicken.position.z = jumpDeltaDistance;
                        break;

                    case "backward":
                        const backPositionY = currentLane * positionWidth * zoom - moveDeltaDistance;
                        camera.position.y = initialCameraPositionY + backPositionY;
                        directionalLight.position.y = -100 + backPositionY;
                        chicken.position.y = backPositionY;
                        chicken.position.z = jumpDeltaDistance;
                        break;

                    case "left":
                        const leftPositionX = (currentColumn * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2 - moveDeltaDistance;
                        camera.position.x = initialCameraPositionX + leftPositionX;
                        directionalLight.position.x = -100 + leftPositionX;
                        chicken.position.x = leftPositionX;
                        chicken.position.z = jumpDeltaDistance;
                        break;

                    case "right":
                        const rightPositionX = (currentColumn * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2 + moveDeltaDistance;
                        camera.position.x = initialCameraPositionX + rightPositionX;
                        directionalLight.position.x = -100 + rightPositionX;
                        chicken.position.x = rightPositionX;
                        chicken.position.z = jumpDeltaDistance;
                        break;
                }

                // Movement completion
                if (moveDeltaTime > currentStepTime) {
                    switch (moves[0]) {
                        case "forward":
                            currentLane++;
                            const lanePoints = 1 * gameState.scoreMultiplier;
                            gameState.score = Math.max(gameState.score, currentLane * lanePoints);
                            gameState.speed = 1 + (currentLane * 0.02); // Gradual speed increase
                            break;
                        case "backward":
                            currentLane--;
                            break;
                        case "left":
                            currentColumn--;
                            break;
                        case "right":
                            currentColumn++;
                            break;
                    }

                    updateHUD();
                    moves.shift();
                    stepStartTimestamp = moves.length === 0 ? null : timestamp;
                }
            }

            if (gameState.isPlaying) {
                checkCollisions();
            }
            renderer.render(scene, camera);
        }

        // Event listeners
        document.getElementById("startButton").addEventListener("click", startGame);
        document.getElementById("restartButton").addEventListener("click", restartGame);

        // Enhanced controls
        document.getElementById("forward").addEventListener("click", () => move("forward"));
        document.getElementById("backward").addEventListener("click", () => move("backward"));
        document.getElementById("left").addEventListener("click", () => move("left"));
        document.getElementById("right").addEventListener("click", () => move("right"));

        // Enhanced keyboard controls with Enter key support
        window.addEventListener("keydown", (event) => {
            if (!gameState.gameStarted) {
                if (event.code === "Space" || event.code === "Enter") {
                    event.preventDefault();
                    startGame();
                }
                return;
            }
            
            if (!gameState.isPlaying) {
                if (event.code === "Enter") {
                    event.preventDefault();
                    restartGame();
                }
                return;
            }
            
            switch(event.code) {
                case "ArrowUp":
                case "KeyW":
                    event.preventDefault();
                    move("forward");
                    break;
                case "ArrowDown":
                case "KeyS":
                    event.preventDefault();
                    move("backward");
                    break;
                case "ArrowLeft":
                case "KeyA":
                    event.preventDefault();
                    move("left");
                    break;
                case "ArrowRight":
                case "KeyD":
                    event.preventDefault();
                    move("right");
                    break;
                case "Space":
                    event.preventDefault();
                    move("forward");
                    break;
            }
        });

        // Responsive design
        window.addEventListener("resize", () => {
            camera.left = window.innerWidth / -2;
            camera.right = window.innerWidth / 2;
            camera.top = window.innerHeight / 2;
            camera.bottom = window.innerHeight / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize high score display and start animation
        updateHUD();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
